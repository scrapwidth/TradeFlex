using TradeFlex.Abstractions;

namespace TradeFlex.Core;

/// <summary>
/// Provides functionality to create and drive trading algorithms.
/// </summary>
public static class AlgorithmRunner
{
    /// <summary>
    /// Instantiates an algorithm of the specified <paramref name="algorithmType"/>.
    /// </summary>
    /// <param name="algorithmType">Concrete algorithm type.</param>
    /// <param name="constructorArgs">Arguments passed to the algorithm constructor.</param>
    /// <returns>The created algorithm instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the type does not implement <see cref="ITradingAlgorithm"/>.</exception>
    public static ITradingAlgorithm CreateAlgorithm(Type algorithmType, params object[] constructorArgs)
    {
        if (!typeof(ITradingAlgorithm).IsAssignableFrom(algorithmType))
        {
            throw new ArgumentException($"Type {algorithmType.FullName} does not implement ITradingAlgorithm.", nameof(algorithmType));
        }

        var instance = Activator.CreateInstance(algorithmType, constructorArgs);
        return (ITradingAlgorithm)instance!;
    }

    /// <summary>
    /// Instantiates an algorithm of type <typeparamref name="T"/>.
    /// </summary>
    /// <param name="constructorArgs">Arguments passed to the algorithm constructor.</param>
    /// <typeparam name="T">Algorithm type implementing <see cref="ITradingAlgorithm"/>.</typeparam>
    /// <returns>The created algorithm instance.</returns>
    public static T CreateAlgorithm<T>(params object[] constructorArgs) where T : ITradingAlgorithm
        => (T)CreateAlgorithm(typeof(T), constructorArgs);

    /// <summary>
    /// Executes the provided algorithm over the supplied bars.
    /// </summary>
    /// <param name="algorithm">Algorithm instance.</param>
    /// <param name="bars">Market data to feed into the algorithm.</param>
    /// <returns>Trades produced by the algorithm.</returns>
    public static List<Trade> Run(ITradingAlgorithm algorithm, IEnumerable<Bar> bars)
    {
        var trades = new List<Trade>();

        algorithm.Initialize();

        foreach (var bar in bars)
        {
            algorithm.OnBar(bar);
        }

        algorithm.OnExit();

        return trades;
    }

    /// <summary>
    /// Convenience method to create and run an algorithm of type <typeparamref name="T"/>.
    /// </summary>
    /// <param name="bars">Bars to process.</param>
    /// <param name="constructorArgs">Constructor arguments for the algorithm.</param>
    /// <typeparam name="T">Concrete algorithm type.</typeparam>
    /// <returns>The list of trades generated by the algorithm.</returns>
    public static List<Trade> Run<T>(IEnumerable<Bar> bars, params object[] constructorArgs) where T : ITradingAlgorithm
    {
        var algo = CreateAlgorithm<T>(constructorArgs);
        return Run(algo, bars);
    }
}

