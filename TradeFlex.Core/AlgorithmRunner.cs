using System.Threading.Tasks;
using TradeFlex.Abstractions;

namespace TradeFlex.Core;

/// <summary>
/// Provides functionality to create and drive trading algorithms.
/// </summary>
public static class AlgorithmRunner
{
    /// <summary>
    /// Instantiates an algorithm of the specified <paramref name="algorithmType"/>.
    /// </summary>
    /// <param name="algorithmType">Concrete algorithm type.</param>
    /// <param name="constructorArgs">Arguments passed to the algorithm constructor.</param>
    /// <returns>The created algorithm instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the type does not implement <see cref="ITradingAlgorithm"/>.</exception>
    public static ITradingAlgorithm CreateAlgorithm(Type algorithmType, params object[] constructorArgs)
    {
        if (!typeof(ITradingAlgorithm).IsAssignableFrom(algorithmType))
        {
            throw new ArgumentException($"Type {algorithmType.FullName} does not implement ITradingAlgorithm.", nameof(algorithmType));
        }

        var instance = Activator.CreateInstance(algorithmType, constructorArgs);
        return (ITradingAlgorithm)instance!;
    }

    /// <summary>
    /// Instantiates an algorithm of type <typeparamref name="T"/>.
    /// </summary>
    /// <param name="constructorArgs">Arguments passed to the algorithm constructor.</param>
    /// <typeparam name="T">Algorithm type implementing <see cref="ITradingAlgorithm"/>.</typeparam>
    /// <returns>The created algorithm instance.</returns>
    public static T CreateAlgorithm<T>(params object[] constructorArgs) where T : ITradingAlgorithm
        => (T)CreateAlgorithm(typeof(T), constructorArgs);

    /// <summary>
    /// Executes the provided algorithm over the supplied bars asynchronously.
    /// </summary>
    /// <param name="algorithm">Algorithm instance.</param>
    /// <param name="bars">Market data to feed into the algorithm.</param>
    /// <returns>Trades produced by the algorithm.</returns>
    public static async Task<List<Trade>> RunAsync(ITradingAlgorithm algorithm, IEnumerable<Bar> bars)
    {
        // Setup Paper Broker for this static run
        var broker = new PaperBroker(100000m);
        var context = new AlgorithmContext(broker);

        await algorithm.InitializeAsync(context);

        foreach (var bar in bars)
        {
            broker.UpdatePrice("SAMPLE", bar.Close);
            await algorithm.OnBarAsync(bar);
        }

        await algorithm.OnExitAsync();

        return new List<Trade>(broker.Trades);
    }

    /// <summary>
    /// Convenience method to create and run an algorithm of type <typeparamref name="T"/> asynchronously.
    /// </summary>
    /// <param name="bars">Bars to process.</param>
    /// <param name="constructorArgs">Constructor arguments for the algorithm.</param>
    /// <typeparam name="T">Concrete algorithm type.</typeparam>
    /// <returns>The list of trades generated by the algorithm.</returns>
    public static async Task<List<Trade>> RunAsync<T>(IEnumerable<Bar> bars, params object[] constructorArgs) where T : ITradingAlgorithm
    {
        var algo = CreateAlgorithm<T>(constructorArgs);
        return await RunAsync(algo, bars);
    }

    private class AlgorithmContext : IAlgorithmContext
    {
        public IBroker Broker { get; }
        public AlgorithmContext(IBroker broker) => Broker = broker;
    }
}
